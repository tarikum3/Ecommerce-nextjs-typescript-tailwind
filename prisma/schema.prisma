generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  // Uses connection pooling
  url       = env("POSTGRES_PRISMA_URL")
  // Uses direct connection, ⚠️ make sure to keep this to `POSTGRES_URL_NON_POOLING`
  // or you'll have dangling databases from migrations
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model Account {
  id                 String  @id @default(cuid())
  userId             String  @map("user_id")
  type               String
  provider           String
  providerAccountId  String  @map("provider_account_id")
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model User {
  id            String    @id @default(cuid())
  firstName     String?
  lastName      String?
  password      String
  phone         String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?

  accounts Account[]
  sessions Session[]

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  EventLog  EventLog[]
  Customer  Customer?
  AdminUser AdminUser?

  @@index([email])
}

model VerificationToken {
  id         Int      @id @default(autoincrement())
  identifier String
  token      String   @unique
  expires    DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([identifier, token])
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Customer {
  id                String    @id @default(cuid())
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  firstName     String?
  lastName      String?
  password      String
  email         String?   @unique
  phone             String?   @unique
  address           String?
  city              String?
  state             String?
  country           String?
  postalCode        String?
  totalOrders       Int       @default(0)
  totalSpent        Float     @default(0)
  lastOrderDate     DateTime?
  averageOrderValue Float     @default(0)

  carts  Cart[]
  orders Order[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([phone])
}

model AdminUser {
  id     String  @id @default(cuid())
  userId String  @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  email  String  @unique
  phone  String? @unique
  image  Image?  @relation(fields: [imageId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  imageId   String?

  @@index([userId])
  @@index([email])
  @@index([phone])
}

model Product {
  id               String              @id @default(uuid())
  name             String
  description      String
  slug             String
  sku              String?
  category         String?
  images           Image[]
  variants         ProductVariant[]
  price            ProductPrice?
  options          ProductOption[]
  vendor           String?
  tags             String[]
  collections      ProductCollection[]
  availableForSale Boolean
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  @@index([slug])
  @@index([vendor])
}

model ProductVariant {
  id               String          @id @default(uuid())
  name             String
  quantity         Int
  price            Float
  productId        String
  product          Product         @relation(fields: [productId], references: [id])
  cartItems        CartItem[]
  availableForSale Boolean
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  variantOptions   VariantOption[] // Relation to define variant options
  OrderItem        OrderItem[]

  @@index([productId])
}

model ProductOption {
  id        String               @id @default(uuid())
  name      String // e.g., Color, Size
  values    ProductOptionValue[]
  productId String
  product   Product              @relation(fields: [productId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId])
}

model ProductOptionValue {
  id             String          @id @default(uuid())
  value          String // e.g., Red, Small
  optionId       String
  option         ProductOption   @relation(fields: [optionId], references: [id])
  variantOptions VariantOption[] // Back-reference to VariantOption

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([optionId])
}

model VariantOption {
  id            String             @id @default(uuid())
  variantId     String
  variant       ProductVariant     @relation(fields: [variantId], references: [id], onDelete: Cascade) // Specify onDelete here
  optionValueId String
  optionValue   ProductOptionValue @relation(fields: [optionValueId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([variantId])
  @@index([optionValueId])
}

model ProductPrice {
  id        String   @id @default(uuid())
  amount    Float
  currency  String
  productId String   @unique
  product   Product? @relation(fields: [productId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId])
}

model Image {
  id        String  @id @default(uuid())
  url       String
  productId String
  product   Product @relation(fields: [productId], references: [id])

  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  AdminUser AdminUser[]

  @@index([productId])
}

model TempImage {
  id         String   @id @default(cuid())
  url        String
  imageFor   String
  supabaseId String // To store the Supabase storage object id
  createdAt  DateTime @default(now())
}

model Collection {
  id          String                    @id @default(uuid())
  title       String
  description String?
  products    ProductCollection[]
  rules       AutomaticCollectionRule[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProductCollection {
  productId    String
  collectionId String
  product      Product    @relation(fields: [productId], references: [id])
  collection   Collection @relation(fields: [collectionId], references: [id])

  @@id([productId, collectionId])
}

model AutomaticCollectionRule {
  id           String     @id @default(uuid())
  field        String
  condition    String
  value        String
  collectionId String
  collection   Collection @relation(fields: [collectionId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Cart {
  id                 String     @id @default(uuid())
  userId             String
  items              CartItem[]
  firstName          String?
  lastName           String?
  postalCode         String?
  email              String?
  companyName        String?
  address            String?
  phone              String?
  country            String?
  city               String?
  billingName        String?
  billingEmail       String?
  billingCompanyName String?
  billingAddress     String?
  paymentMethod      String?
  deliveryMethod     String?
  subtotalPrice      Float?
  totalPrice         Float?
  currency           String?
  step               String?

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  Customer   Customer? @relation(fields: [customerId], references: [id])
  customerId String?

  @@index([userId])
}

model CartItem {
  id        String         @id @default(uuid())
  variantId String
  variant   ProductVariant @relation(fields: [variantId], references: [id])
  quantity  Int
  cartId    String
  cart      Cart           @relation(fields: [cartId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([variantId])
  @@index([cartId])
}

model Order {
  id                 String      @id @default(uuid())
  userId             String
  items              OrderItem[]
  firstName          String?
  lastName           String?
  email              String?
  phone              String?
  companyName        String?
  address            String?
  city               String?
  country            String?
  postalCode         String?
  billingName        String?
  billingEmail       String?
  billingCompanyName String?
  billingAddress     String?
  paymentMethod      String?
  deliveryMethod     String?
  currency           String?
  subtotalPrice      Float
  totalPrice         Float
  status             OrderStatus @default(PENDING)
  step               String?

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  Customer   Customer? @relation(fields: [customerId], references: [id])
  customerId String?

  @@index([userId])
}

model OrderItem {
  id        String         @id @default(uuid())
  orderId   String
  order     Order          @relation(fields: [orderId], references: [id])
  variantId String
  variant   ProductVariant @relation(fields: [variantId], references: [id])
  quantity  Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([variantId])
}

enum OrderStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELED
  REFUNDED
}

model EventLog {
  id           String   @id @default(uuid())
  userId       String
  resourceName String
  action       String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id])

  @@index([userId])
}

// Commented out models

// model DeliveryMethod {
//   id        String   @id @default(uuid())
//   price    Float
//   name     String
//   description String
// }

// model PaymentMethod {
//   id        String   @id @default(uuid())
//   price    Float?
//   name     String
//   description String
// }

model Schedule {
  id           String       @id @default(uuid())
  name         String
  startDate    DateTime
  endDate      DateTime
  days         DayEnum[]    @default([]) // Stores predefined days as ENUMs
  scheduleType ScheduleType
  daysRelation Day[]        @relation("DaySchedules") // Many-to-many with Day
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

model Day {
  id        String     @id @default(uuid())
  date      DateTime   @db.Date // Stores only DATE (No Time) in PostgreSQL
  dayName   DayEnum
  year      String
  schedules Schedule[] @relation("DaySchedules") // Many-to-many with Schedule
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

enum ScheduleType {
  MEETING
  APPOINTMENT
  PERSONAL
}

enum DayEnum {
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
}
