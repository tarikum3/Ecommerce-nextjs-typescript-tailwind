generator client {
  provider = "prisma-client-js"
}
 
datasource db {
  provider = "postgresql"
  // Uses connection pooling
  url = env("POSTGRES_PRISMA_URL")
  // Uses direct connection, ⚠️ make sure to keep this to `POSTGRES_URL_NON_POOLING`
  // or you'll have dangling databases from migrations
  directUrl = env("POSTGRES_URL_NON_POOLING")
}
 
model Customer {
  id        Int      @id @default(autoincrement())
  firstName     String
  lastName      String
  password      String
  email         String   @unique
  phone         String?   
  image         String? 
  createdAt DateTime @default(now())
}

model Product {
  id             String          @id @default(uuid())
  name           String
  description    String
  slug           String
  sku            String?
  category       String?
  images         Image[]
  variants       ProductVariant[]
  price          ProductPrice?
  options        ProductOption[]
  vendor         String?
  tags           String[]
  collections    ProductCollection[]
  
  createdAt DateTime @default(now())
}



model ProductVariant {
  id        String   @id @default(uuid())
  name      String
  quantity  Int
  price    Float
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  cartItems      CartItem[]
}



model ProductOption {
  id        String   @id @default(uuid())
  name      String
  values    String[]
  productId String
  product   Product  @relation(fields: [productId], references: [id])
}
model ProductPrice {
  id        String   @id @default(uuid())
  amount    Float
  currency  String
  productId String   @unique
  product   Product? @relation(fields: [productId], references: [id])
}
model Image {
  id        String   @id @default(uuid())
  url       String
  productId String
  product   Product  @relation(fields: [productId], references: [id])
}
model Collection {
  id             String                @id @default(uuid())
  title          String
  description    String?
  products       ProductCollection[]
  rules          AutomaticCollectionRule[]
}

model ProductCollection {
  productId    String
  collectionId String
  product      Product    @relation(fields: [productId], references: [id])
  collection   Collection @relation(fields: [collectionId], references: [id])
  @@id([productId, collectionId])
}

model AutomaticCollectionRule {
  id             String     @id @default(uuid())
  field          String
  condition      String
  value          String
  collectionId   String
  collection     Collection @relation(fields: [collectionId], references: [id])
}



model Cart {
  id                String      @id @default(uuid())
  customerId        String
  items             CartItem[]
  firstName          String?
  lastName          String?
   postalCode       String?
  email             String?
  companyName       String?
    address           String?
  phone             String?
  country           String?
  city              String?
  billingName       String?
  billingEmail      String?
  billingCompanyName String?
  billingAddress  String?
  paymentMethod     String?
  deliveryMethod    String?
  subtotalPrice    Float? 
  totalPrice       Float?
  currency          String?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
}

// model DeliveryMethod {
//   id        String   @id @default(uuid())
//   price    Float
//   name     String
//   description String

// }
// model PaymentMethod {
//   id        String   @id @default(uuid())
//   price    Float?
//   name     String
//   description String

// }
model CartItem {
  id         String      @id @default(uuid())
  variantId  String
  variant    ProductVariant     @relation(fields: [variantId], references: [id])
  quantity   Int
  cartId     String
  cart       Cart        @relation(fields: [cartId], references: [id])
}











